"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateGoWork = void 0;
const can_use_go_work_1 = require("./can-use-go.work");
const constants_1 = require("./constants");
const go_version_1 = require("./go-version");
const MODULES_REGEX = /use\s+\((?<modules>[^)]*)\)/g;
function updateGoWorkUses(fileContent, newProject) {
    const execResult = MODULES_REGEX.exec(fileContent);
    let modules;
    if (execResult) {
        const groups = execResult.groups;
        modules = [...new Set([...groups['modules'].split(/(\s+)/), newProject])].sort();
    }
    else {
        modules = [newProject];
    }
    const formattedModules = modules.reduce((ac, m) => {
        const moduleName = m.trim();
        return moduleName.length ? `${ac}\t${moduleName}\n` : ac;
    }, '');
    return fileContent.replace(MODULES_REGEX, `use (\n${formattedModules})`);
}
function updateGoWork(tree, options) {
    if (options.useGoWork) {
        if (!tree.exists(constants_1.GO_WORK_FILE)) {
            if (!options.skipVersionCheck && !(0, can_use_go_work_1.canUseGoWork)()) {
                throw new Error('Your version of go does not support workspaces');
            }
            const [major, minor] = options.skipVersionCheck ? ['1', '18'] : (0, go_version_1.getGoVersion)().split('.');
            tree.write(constants_1.GO_WORK_FILE, `go ${major}.${minor}\n\nuse (\n    ${options.projectRoot}\n)\n`);
            return;
        }
        const fileContent = tree.read(constants_1.GO_WORK_FILE).toString();
        const newFileContent = updateGoWorkUses(fileContent, options.projectRoot);
        tree.write(constants_1.GO_WORK_FILE, newFileContent);
    }
}
exports.updateGoWork = updateGoWork;
//# sourceMappingURL=update-go-work.helper.js.map