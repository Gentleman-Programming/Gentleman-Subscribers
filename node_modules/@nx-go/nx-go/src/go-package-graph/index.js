"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processProjectGraph = void 0;
const devkit_1 = require("@nrwl/devkit");
const path_1 = require("path");
const child_process_1 = require("child_process");
const find_workspace_root_path_1 = require("../utils/find-workspace-root-path");
const processProjectGraph = (graph, context) => {
    const workspaceRootPath = (0, find_workspace_root_path_1.findNxWorkspaceRootPath)();
    const goModules = getGoModules(workspaceRootPath);
    const projectRootLookupMap = new Map();
    for (const projectName in graph.nodes) {
        projectRootLookupMap.set(graph.nodes[projectName].data.root, projectName);
    }
    const builder = new devkit_1.ProjectGraphBuilder(graph);
    // Define dependencies using the context of files that were changed to minimize work
    // between each run.
    for (const projectName in context.filesToProcess) {
        context.filesToProcess[projectName]
            .filter((f) => (0, path_1.extname)(f.file) === '.go')
            .map(({ file }) => ({
            projectName,
            file,
            dependencies: getGoDependencies(workspaceRootPath, goModules, projectRootLookupMap, file),
        }))
            .filter((data) => data.dependencies && data.dependencies.length > 0)
            .forEach(({ projectName, file, dependencies }) => dependencies.forEach((dependency) => builder.addExplicitDependency(projectName, file, dependency)));
    }
    return builder.getUpdatedProjectGraph();
};
exports.processProjectGraph = processProjectGraph;
/**
 * getGoDependencies will use `go list` to get dependency information from a go file
 * @param workspaceRootPath
 * @param goModules
 * @param projectRootLookup
 * @param file
 * @returns
 */
const getGoDependencies = (workspaceRootPath, goModules, projectRootLookup, file) => {
    var _a;
    try {
        const goPackageDataJson = (0, child_process_1.execSync)('go list -json ./' + file, { encoding: 'utf-8', cwd: workspaceRootPath });
        const goPackage = JSON.parse(goPackageDataJson);
        const isTestFile = (0, path_1.basename)(file, '.go').endsWith('_test');
        // Use the correct imports list even if the file is a test file.
        const listOfImports = (_a = (!isTestFile ? goPackage.Imports : goPackage.TestImports)) !== null && _a !== void 0 ? _a : [];
        return listOfImports
            .map((goImport) => ({ goImport, goModule: goModules.find((m) => goImport.startsWith(m.Path)) }))
            .filter((importInfo) => importInfo.goModule)
            .map(({ goImport, goModule }) => getProjectNameForGoImport(workspaceRootPath, goImport, goModule, projectRootLookup))
            .filter((projectName) => projectName);
    }
    catch (ex) {
        console.error(`Error processing ${file}`);
        console.error(ex);
        return []; // Return an empty array so that we can process other files
    }
};
/**
 * Parses go modules in a way that work with Go workspaces if they are used.
 * @param workspaceRootPath
 */
const getGoModules = (workspaceRootPath) => {
    const goModuleJSON = (0, child_process_1.execSync)('go list -m -json', { encoding: 'utf-8', cwd: workspaceRootPath });
    return (goModuleJSON
        .split('}')
        .filter((block) => block.trim().length > 0)
        .map((toParse) => JSON.parse(toParse + '}'))
        // Sort and reverse the modules so when looking up a go import we will encounter the most specific path first
        .sort((a, b) => a.Path.localeCompare(b.Path))
        .reverse());
};
/**
 * Gets the project name for the go import by getting the relative path for the import with in the go module system
 * then uses that to calculate the relative path on disk and looks up which project in the workspace the import is a part
 * of.
 * @param workspaceRootPath
 * @param importPath
 * @param module
 * @param projectRootLookup
 */
const getProjectNameForGoImport = (workspaceRootPath, importPath, module, projectRootLookup) => {
    const relativeImportPath = importPath.substring(module.Path.length + 1);
    const relativeModuleDir = module.Dir.substring(workspaceRootPath.length + 1);
    let projectPath = relativeModuleDir ? relativeModuleDir + '/' + relativeImportPath : relativeImportPath;
    while (projectPath !== '.') {
        if (projectPath.endsWith('/')) {
            projectPath = projectPath.slice(0, -1);
        }
        const projectName = projectRootLookup.get(projectPath);
        if (projectName) {
            return projectName;
        }
        projectPath = (0, path_1.dirname)(projectPath);
    }
    return null;
};
//# sourceMappingURL=index.js.map