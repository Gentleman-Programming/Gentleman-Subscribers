"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isVersionAfter = exports.getGoVersion = exports.updateGoWork = exports.createGoMod = exports.runGoCommand = void 0;
const path_1 = require("path");
const child_process_1 = require("child_process");
const MODULES_REGEX = /use\s+\((?<modules>[^)]*)\)/g;
const GO_MOD_FILE = 'go.mod';
const GO_WORK_FILE = 'go.work';
function runGoCommand(context, command, params, options = {}) {
    // Take the parameters or set defaults
    const cmd = options.cmd || 'go';
    const cwd = options.cwd || process.cwd();
    // Create the command to execute
    const execute = `${cmd} ${command} ${params.join(' ')}`;
    try {
        console.log(`Executing command: ${execute}`);
        (0, child_process_1.execSync)(execute, { cwd, stdio: [0, 1, 2] });
        return { success: true };
    }
    catch (e) {
        console.error(`Failed to execute command: ${execute}`, e);
        return { success: false };
    }
}
exports.runGoCommand = runGoCommand;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function createGoMod(tree, { projectRoot }) {
    const filePath = (0, path_1.join)(projectRoot, GO_MOD_FILE);
    const moduleName = projectRoot;
    if (!tree.exists(filePath)) {
        tree.write(filePath, `module ${moduleName}\n`);
    }
}
exports.createGoMod = createGoMod;
function updateGoWorkUses(fileContent, newProject) {
    const execResult = MODULES_REGEX.exec(fileContent);
    let modules;
    if (execResult) {
        const groups = execResult.groups;
        modules = [
            ...new Set([...groups['modules'].split(/(\s+)/), newProject]),
        ].sort();
    }
    else {
        modules = [newProject];
    }
    const formattedModules = modules.reduce((ac, m) => {
        const moduleName = m.trim();
        return moduleName.length ? `${ac}\t${moduleName}\n` : ac;
    }, '');
    return fileContent.replace(MODULES_REGEX, `use (\n${formattedModules})`);
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function updateGoWork(tree, options) {
    if (!tree.exists(GO_WORK_FILE)) {
        if (!canUseGoWork()) {
            throw new Error('Your version of go does not support workspaces');
        }
        const [major, minor] = getGoVersion().split('.');
        tree.write(GO_WORK_FILE, `go ${major}.${minor}\n\nuse (\n    ${options.projectRoot}\n)\n`);
        return;
    }
    const fileContent = tree.read(GO_WORK_FILE).toString();
    const newFileContent = updateGoWorkUses(fileContent, options.projectRoot);
    tree.write(GO_WORK_FILE, newFileContent);
}
exports.updateGoWork = updateGoWork;
const GO_VERSION_REGEX = /go(?<version>\S+) /;
function getGoVersion() {
    const output = (0, child_process_1.execSync)('go version');
    if (output) {
        return GO_VERSION_REGEX.exec(output.toString()).groups.version;
    }
    else {
        throw new Error('Fail to retrieve Go version');
    }
}
exports.getGoVersion = getGoVersion;
function versionAsNum(version) {
    return parseInt(version) || 0;
}
function isVersionAfter(version, refVersion) {
    const [sMajor, sMinor, sPatch] = version.split('.');
    const [sRefMajor, sRefMinor, sRefPatch] = refVersion.split('.');
    const major = versionAsNum(sMajor);
    const refMajor = versionAsNum(sRefMajor);
    if (major != refMajor) {
        return major > refMajor;
    }
    const minor = versionAsNum(sMinor);
    const refMinor = versionAsNum(sRefMinor);
    if (minor != refMinor) {
        return minor > refMinor;
    }
    const patch = versionAsNum(sPatch);
    const refPatch = versionAsNum(sRefPatch);
    return patch >= refPatch;
}
exports.isVersionAfter = isVersionAfter;
function canUseGoWork() {
    const version = getGoVersion();
    return isVersionAfter(version, '1.18');
}
//# sourceMappingURL=go.helper.js.map